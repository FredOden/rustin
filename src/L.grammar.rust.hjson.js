{
	"rules" : {

		variable: {
			~Identifier:
			$0
			,"~Identifier [ &factor ]" :
			$0[$2]
		}

		,"atom" : {
			"@Number":
			$0f64
			, "pi__" : std::f64::consts::PI
			, "&variable":
			$0
			, "( &factor )":
			$1
			,"sqr__ &atom":
			$1.sqrt()
			,"&atom rad__":
			$0*std::f64::consts::PI/180f64
			,"&atom deg__":
			$0*180f64/std::f64::consts::PI
			,"Math !Error!( !Error!&factorA !Error!)":
			($2).$0()
			, "~Identifier &callParams":
			$0$1
			, "Comment":
			"Lourah.utils.text.Parser.NOTHING"

		}

		,"factor" : {
			"&factorL":
			"$0"
			,"not &factorL":
			"!$1"
		}

		,"operatorL": {
			"eq" : "=="
			,"ne" : "!="
			,"ge" : ">="
			,"gt" : ">"
			,"le" : "<="
			,"lt" : "<"
		}

		,"factorL" : {
			"&factorL &operatorL &factorL":
			($0 as f64) $1 ($2 as f64)
			,"&factorB":
			$0
		}


		,"factorB" : {
			"&factorB OperatorB &factorB":
			"$0 as f64 $1 $2 as f64"
			,"&factorA":
			$0
		}

		,"factorA": {
			"&factorA OperatorA &factorA":
			"$0 as f64 $1 $2 as f64"

			,"OperatorA &atom":
			$0 $1
			,"&factorM":
			"$0"
		}

		,"factorM": {
			"&factorM OperatorM &factorM":
			"$0 as f64 $1 $2 as f64"
			,"&atom":
			"$0"
		}

		,"expr" : {
			"&variable = &expr":
			"let mut $0 = $2;"
			,"&factor ;":
			"$0"
			,";":
			""
			, '''
			print &atom ;
			''':
			'''
			{
				let t__ = $1;
				println!("{t__}");
				t__
			}
			'''
			, "if &factor then &expr":
			" if $1 { _ = $3; }"
			, '''
			if !Error!&factor !Error!then !Error!&expr else !Error!&expr
			''':
			'''
			if $1 {
				$3
			}
			else {
				$5
			}
			'''
			, "&block":
			"$0"
			, "for &variable = &factor to &factor &expr":
			'''
			for $1 in ($3).round() as i64..=($5).round() as i64 {
				_ = $6;
			}
			'''
			, "for &variable = &factor to &factor step &factor &expr":
			"{ var v = $1; var step = Number($7); var from = Number($3); var to = Number($5); if (step === 0 { throw \"for::error::step = \" + step; } vars = new Scope(vars); vars.declare(v); if ((step >0?(to <  from):(to > from)) { throw \"for::error::to(\"+to+ ((step>0?\") < from(\":\") > from(\") + from +\")\"; } for(vars.set(v, from); (step>0?(vars.get(v) <= to):(vars.get(v) >= to); vars.set(v, vars.get(v) + step)) { $8; } vars = vars.getEnclosing; return $8; }"
			,"def ~Identifier &defParams &expr":
			'''
			fn $1 $2 -> f64 {
				$3
			}
			'''
		}

		, "defParams" : {
			"( )":
			"()"
			,"( &defList )":
			"($1)"
		}

		, "defList" : {
			"~Identifier":
			"$0:f64"
			,"~Identifier , &defList":
			"$0:f64, $2"
		}

		, "callParams" : {
			"( )":
			"()"
			,"( &callList )":
			"($1)"
		}

		, "callList" : {
			"&factor":
			"$0 as f64"
			,"&factor , &callList":
			"$0 as f64, $2"
		}

		, "statement" : {
			"&expr":
			"$0"
			, "&expr &statement":
			"$0;  $1"
			, "&expr &statement &statement":
			"$0; $1; $2"
		}

		, "block" : {
			"{ &statement }":
			"{ $1 }"
		}

		, "program" : {
			"&statement" :
			'''
			// generated by rustin
			// (c) 2024, Frederic Oden 
			fn main() {
				$0;
			}
			'''
		}

	}
}

